//
//  Watson.h
//  Watson
//
//  Created by Alex Gerome on 7/24/15.
//  Objective-C implementation of the Watson Robotics SDK
//  This class implements core robotics services provided by Watson
//
//  IBM Confidential
//  OCO Source Materials
//
//  5727-I17
//  (C) Copyright IBM Corp. 2001, 2015 All Rights Reserved.
//
//  The source code for this program is not published or otherwise
//  divested of its trade secrets, irrespective of what has been
//  deposited with the U.S. Copyright Office.
//
//  END_COPYRIGHT

#ifndef Watson_Watson_h
#define Watson_Watson_h

@interface Watson : NSObject

//make readonlys?
@property (nonatomic) NSString *config;
@property (nonatomic, readonly) NSString *license;
@property (nonatomic) NSString *mac_id;
@property (nonatomic) NSString *key;
@property (nonatomic) NSString *client_url;
@property (nonatomic, readonly, getter=getAudioOutputPath) NSString *ttspath;
@property (nonatomic, readonly, getter=getAudioInputPath) NSString *audio_path;
@property (nonatomic) NSString *personality_id;
@property (nonatomic) NSString *chat_id;

-(NSString *)initialize_chat:(NSString *)instance_id;
-(NSString *)ask:(NSString *)query;
-(NSString *)thunderstone:(NSString *)query;
-(NSString *)stt;
-(void)tts:(NSString *)text voice:(NSString *)voice headers:(NSDictionary *)headers params:(NSDictionary *)params;
-(NSString *)personality:(NSString *)body headers:(NSDictionary *)headers params:(NSDictionary *)params;
-(NSString *)tradeoff:(NSString *)body headers:(NSDictionary *)headers params:(NSDictionary *)params;
-(NSString *)translate:(NSString *)text from:(NSString *)languageFrom to:(NSString *)languageTo headers:(NSDictionary *)headers params:(NSDictionary *)params;
-(NSString *)translate_easy:(NSString *)text from:(NSString *)languageFrom to:(NSString *)languageTo;
-(NSString *)body_check:(NSString *)body except:(NSString *)exceptionType;
-(NSString *)invoke_post:(NSDictionary *)headers body:(NSString *)body service:(NSString *)serviceName params:(NSDictionary *)params;
-(NSString *)invoke_get:(NSDictionary *)headers service:(NSString *)serviceName params:(NSDictionary *)params;
-(NSDictionary *)createHeaders:(NSDictionary *)additionalHeaders;

@end
/*
 import json
 import os
 from os.path import expanduser
 import socket
 import requests
 import base64
 import uuid
 import ConfigParser
 
 class Watson():
 """Watson python service. This makes direct calls to the robot gateway for Watson supported services."""
 def __init__(self):
 self.config = ConfigParser.ConfigParser()
 self.config.read(expanduser("~") + "/" + "/config.ini")
 
 try:
 self.license = json.loads(open(expanduser("~") + "/" + self.config.get('WATSON', 'LICENSE'), 'r+').read())
 except:
 raise RuntimeError(self.config.get('WATSON', 'LICENSE_ERROR'))
 self.mac_id = self.get_mac_id()
 self.key = self.get_key()
 self.client_url = self.get_gateway_URL()
 
 self.ttspath = expanduser("~") + "/" + self.config.get('WATSON', 'AUDIO_OUTPUT_PATH')
 self.audio_path = expanduser("~") + "/" + self.config.get('WATSON', 'AUDIO_INPUT_PATH')
 self.personality_id = ''
 
 def initialize_chat(self, instance_id):
 """Initializes a client for a dialog instance in Cognea. It also sets a Chat id for subsequent calls to ask.
 :param instance_id: The Cognea instance that you want to hit."""
 self.personality_id = instance_id
 # get chat ID
 init_chat_resp = self.invoke_get({'Content-Type':'application/json'}, 'initDialog', params = {'id' : instance_id})
 try:
 init_response = json.loads(init_chat_resp)
 self.chat_id = init_response['id']
 return str(init_response['response'].encode('utf-8'))
 except (IOError, IndexError) as err:
 raise RuntimeError('Error getting the Chat ID: {}'.format(err))
 
 def ask(self, query):
 """Make conversational query to Watson dialog with the chat that has been initialized.
 initialize_chat must be called first.
 :param query: The sentence to be sent to Cognea/dialog"""
 result = self.invoke_get({'Content-Type':'application/json'}, 'askDialog', params = { 'text':query, 'id':self.personality_id, 'chatID':self.chat_id})
 response = json.loads(result)
 response = response["response"]
 return str(response.encode('utf-8'))
 
 def thunderstone(self, query):
 """Sends a question to the thunderstone pipeline
 :param query: The question to be answered by thunderstone"""
 headers = {'Service-Type':'thunderstone','Content-Type':'application/json'}
 response=self.invoke_post(headers = headers, params = None, body = query, serviceName = 'thunderstone')
 return str(response.content)
 
 def stt(self):
 """Sets up a call to bluemix speech to text using a wav file generated by the robot.
 It needs to be stored at the location specified by AUDIO_INPUT_PATH (self.audio_path)"""
 with open(self.audio_path, "rb") as fd:
 encoded_string = base64.b64encode(fd.read())
 response = self.invoke_post(headers={'Service-Type':'stt'}, params=None, body=encoded_string, serviceName='stt')
 response = response.text
 response = response.encode('utf-8')
 response = response.replace('\n','')
 response = response.replace('  ','')
 response = response[3:-3]
 response = json.loads(response)
 try:
 response = str(response["results"][0]["alternatives"][0]["transcript"])
 except:
 response = self.config.get('WATSON', 'STT_ERROR_JSON')
 return response
 
 def tts(self, text, voice = None, headers = None, params = None):
 """Sets up a call to bluemix text to speech. This returns an audio file from bluemix, and
 it must be played by the robot. It is at the location specified by AUDIO_OUTPUT_PATH
 (self.ttspath)
 :param text: The text to be turned into speech
 :param voice: The voice used to speak the text. These voices are specified by Bluemix.
 :param headers: Additional headers that are passed in for the call
 :param params: Additional parameters that are passed in for the call"""
 merged_headers = merge_dicts(headers, {'Content-Type':'application/json', 'Service-Type':'tts'})
 if params == None:
 params = {'accept':'audio/wav'}
 else:
 params['accept'] = 'audio/wav'
 if voice != None:
 params['voice'] = voice
 if os.path.isfile(self.ttspath):
 os.remove(self.ttspath)
 payload = json.dumps({'text': text})
 data = self.invoke_post(headers=merged_headers, params=params, body=payload, serviceName='tts').content
 data=bytearray(data)
 with open(self.ttspath,'wb') as tts_file:
 tts_file.write(data)
 
 def personality(self, body, headers=None,params=None):
 """Make a personality insights post. It analyses a block of text to determine personality traits.
 This requires at least 100 words to be sent in 'body', but around 2000 are recommended.
 :param body: The block of text to be sent to Watson for personality evaluation
 :param headers: Additional headers that are passed in for the call
 :param params: Additional parameters that are passed in for the call"""
 body, success = self.body_check(body, ValueError)
 if not success:
 body=json.dumps({"contentItems":[{"content": body }]})
 merged_headers = merge_dicts(headers, {'Content-Type':'application/json', 'Service-Type':'personality-insights'})
 return self.invoke_post(headers=merged_headers, params=params, body=body, serviceName='personality-insights').content
 
 def tradeoff(self, body, headers=None,params=None):
 """Make a tradeoff analytics post on Bluemix. It analyzes many choices to help determine which
 option is the best given various tradeoffs.
 :param body: Specially formatted table-like json to query Watson
 :param headers: Additional headers that are passed in for the call
 :param params: Additional parameters that are passed in for the call"""
 body, success = self.body_check(body, ValueError)
 if not success:
 raise RuntimeError(self.config.get('WATSON', 'TRADEOFF_ERROR'))
 merged_headers = merge_dicts(headers, {'Content-Type':'application/json', 'Service-Type':'tradeoff-analytics'})
 return self.invoke_post(headers=merged_headers, params=params, body=body, serviceName='tradeoff-analytics').content
 
 def translate(self, text, languageFrom=None, languageTo=None, headers=None, params=None):
 """Make a translation post. This translates something from one language to another intelligently
 :param text: The block of text to be translated
 :param languageFrom: The language that the text is currently in (origin language, or base language)
 :param languageTo: The destination language for the text
 :param headers: Additional headers that are passed in for the call
 :param params: Additional parameters that are passed in for the call"""
 body, success = self.body_check(text, ValueError)
 if not success:
 return self.translate_easy(text,languageFrom,languageTo)
 merged_headers = merge_dicts(headers, {'Content-Type':'application/json', 'Service-Type':'language-translation'})
 return self.invoke_post(headers=merged_headers, params=params, body=body, serviceName='language-translation').content
 
 def translate_easy(self, text, languageFrom, languageTo):
 """Helper for translation that formats the body string if it is given as plain text
 :param text: The block of text to be translated
 :param languageFrom: The language that the text is currently in (origin language, or base language)
 :param languageTo: The destination language for the text"""
 english = self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ENGLISH').split(",")
 spanish = self.config.get('WATSON', 'LANGUAGE_TRANSLATION_SPANISH').split(",")
 french = self.config.get('WATSON', 'LANGUAGE_TRANSLATION_FRENCH').split(",")
 portuguese = self.config.get('WATSON', 'LANGUAGE_TRANSLATION_PORTUGUESE').split(",")
 arabic = self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ARABIC').split(",")
 text = unicode(text,'utf-8')
 if languageFrom.lower() in english:
 if languageTo.lower() in spanish:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ENGLISH_TO_SPANISH'), 'text': text}
 elif languageTo.lower() in french:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ENGLISH_TO_FRENCH'), 'text': text}
 elif languageTo.lower() in portuguese:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ENGLISH_TO_PORTUGUESE'), 'text': text}
 elif languageTo.lower() in arabic:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ENGLISH_TO_ARABIC'), 'text':text}
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_ENGLISH')
 elif languageFrom.lower() in spanish:
 if languageTo.lower() in english:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_SPANISH_TO_ENGLISH'), 'text': text, }
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_SPANISH')
 elif languageFrom.lower() in french:
 if languageTo.lower() in english:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_FRENCH_TO_ENGLISH'), 'text': text}
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_FRENCH')
 elif languageFrom.lower() in portuguese:
 if languageTo.lower() in english:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_PORTUGUESE_TO_ENGLISH'), 'text': text}
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_PORTUGUESE')
 elif languageFrom.lower() in arabic:
 if languageTo.lower() in english:
 payload = {'model_id': self.config.get('WATSON', 'LANGUAGE_TRANSLATION_ARABIC_TO_ENGLISH'), 'text': text}
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_ARABIC')
 else:
 return self.config.get('WATSON', 'LANGUAGE_TRANLATION_ERROR_ALL')
 
 headers = {'Content-type': 'application/json','Service-Type':'language-translation'}
 payload = json.dumps(payload)
 return self.invoke_post(headers=headers, params=None, body=payload, serviceName='language-translation').content
 
 def body_check(self, body, exception_type):
 """Helper to check if a string is formatted correctly for the REST call
 :param body: The body, or text that is being sent to a REST service
 :param exception_type: The type of exception that you want to catch"""
 if isinstance(body,dict):
 body=json.dumps(body)
 else:
 try:
 json.loads(body)
 except exception_type:
 return body, False
 return body, True
 
 def get_ttspath(self):
 """Getter for tts_response path. This returns the path for audio output."""
 return self.ttspath
 
 def get_key(self):
 """Extracts the robot key from a license file. It is used when sending data to the gateway to ensure the robot is registered."""
 return self.license['ROBOT_KEY']
 
 def get_mac_id(self):
 """Extracts the mac id from the robot. It is used when sending data to the gateway to ensure the robot is registered."""
 mac = uuid.getnode()
 return ':'.join('%02X' % ((mac >> 8*i) & 0xff) for i in reversed(xrange(6)))
 
 def get_gateway_URL(self):
 """Extracts the Gateway URL from the license file. This is the location of the gateway to send calls to."""
 return self.license['ROBOT_GATEWAY_URL']
 
 def invoke_post(self, headers, body, serviceName, params = None):
 """Universal method to format a post request
 :param headers: Headers used in the post call
 :param body: The text being posted
 :param serviceName: The service that is being called
 :param params: Parameters for the post call"""
 service_map = self.config.get('WATSON', 'SERVICE_MAP')
 service_map = json.loads(service_map)
 url = '{}/{}'.format(self.client_url, service_map[serviceName])
 headers = self.createHeaders(headers)
 return requests.request('POST', url, headers=headers, data=body, params=params)
 
 def invoke_get(self, headers, serviceName, params = None):
 """Universal method to format a get request
 :param headers: Headers used in the get call
 :param serviceName: The service that is being called
 :param params: Parameters for the get call"""
 service_map = self.config.get('WATSON', 'SERVICE_MAP')
 service_map = json.loads(service_map)
 url = '{}/{}'.format(self.client_url, service_map[serviceName])
 headers = self.createHeaders(headers)
 return requests.get(url, headers=headers, params=params).text
 
 def createHeaders(self, additional_headers):
 """Helper method to construct common headers
 :param additional_headers: Headers to be added to the normal set of headers used in calls"""
 mergedHeaders = merge_dicts(additional_headers, {'MAC_ID':self.mac_id,'ROBOT_KEY': self.key})
 return mergedHeaders
 
 def merge_dicts(x,y):
 """Merges two dictionaries together (appends one to the other)
 :param x: The first dictionary to be merged
 :param y: The second dictionary to be merged"""
 if x == None and y == None:
 return None
 elif x == None:
 return y
 elif y == None:
 return x
 z = x.copy()
 z.update(y)
 return z
 */

#endif
